# Лабораторная работа №9
## Архитектура ЭВМ
### Студент: ИБРАХИМ ХИССЕИН ГАНА
### Группа: НПИбд 01-25
### Дата: 06.12.2025

## 1. Цель работы
Приобретение навыков написания программ с использованием подпрограмм. Знакомство с методами отладки при помощи GDB и его основными возможностями.

## 2. Реализация подпрограмм в NASM

### 2.1 Программа lab09-1.asm (вычисление 2x+7)
**Исходная программа:**
```assembly
%include 'in_out.asm'

SECTION .data
    msg: DB 'Введите x: ',0
    result: DB '2x+7=',0

SECTION .bss
    x: RESB 80
    res: RESB 80

SECTION .text
GLOBAL _start
_start:
    mov eax, msg
    call sprint
    mov ecx, x
    mov edx, 80
    call sread
    mov eax,x
    call atoi
    call _calcul
    mov eax,result
    call sprint
    mov eax,[res]
    call iprintLF
    call quit

_calcul:
    mov ebx,2
    mul ebx
    add eax,7
    mov [res],eax
    ret
Создание файлов:
https://captures/capture01.png

Тестирование оригинальной программы (x=5 → 17):
https://captures/capture03.png

2.2 Модификация с подпрограммой _subcalcul
Измененный код (добавлена _subcalcul для g(x)=3x-1):

_subcalcul:
     mov ebx, 3
     mul ebx      ; eax = 3*x
     sub eax, 1   ; eax = 3*x - 1
     ret    

_calcul:
    call _subcalcul  ; eax = g(x)
    mov ebx, 2
    mul ebx          ; eax = 2 * g(x)
    add eax, 7       ; eax = 2*g(x) + 7
    mov [res], eax
    ret

Код после исправления синтаксических ошибок:
https://captures/capture04.png

Компиляция исправленной программы:
https://captures/capture05.png

Тестирование модифицированной программы:

x=2 → f(g(2)) = 2(32-1)+7 = 2*5+7 = 17

x=4 → f(g(4)) = 2(34-1)+7 = 2*11+7 = 29

x=0 → f(g(0)) = 2(30-1)+7 = 2*(-1)+7 = 5

https://captures/capture06.png

3. Отладка с помощью GDB
3.1 Программа Hello World (lab09-2.asm)
Исходный код программы:

SECTION .data
    msg1:    db "Hello, ",0x0
    msg1Len:   equ $ - msg1
    msg2:    db "world!",0xa
    msg2Len:   equ $ - msg2

SECTION .text
    global _start
_start:
    mov eax, 4
    mov ebx, 1
    mov ecx, msg1
    mov edx, msg1Len
    int 0x80
    mov eax, 4
    mov ebx, 1
    mov ecx, msg2
    mov edx, msg2Len
    int 0x80
    mov eax, 1
    mov ebx, 0
    int 0x80

Создание файла:
https://captures/capture07.png

Компиляция с отладочной информацией (-g):
https://captures/capture08.png

Запуск программы в GDB:
https://captures/capture09.png

3.2 Основные возможности GDB
Установка точки останова на _start:
https://captures/capture10.png

Дизассемблирование (синтаксис AT&T и Intel):
https://captures/capture11.png

Графический режим GDB (layout asm + layout regs):
https://captures/capture12.png

Установка точки останова по адресу инструкции:
https://captures/capture13.png

Просмотр регистров (info registers):
https://captures/capture14.png

Просмотр содержимого памяти (команда x):
https://captures/capture15.png

Изменение содержимого памяти:
https://captures/capture16.png

Работа с регистрами (разные форматы вывода):
https://captures/capture17.png

3.3 Аргументы командной строки (lab09-3.asm)
Создание файла lab09-3.asm:
https://captures/capture18.png

Компиляция программы:
https://captures/capture19.png

Запуск GDB с аргументами:
https://captures/capture20.png

Анализ расположения аргументов в стеке:
https://captures/capture21.png

x/x $esp → 0x00000004 (4 аргумента: программа + 3 аргумента)

x/s *(void**)($esp + 4) → "/home/.../lab09-3" (имя программы)

x/s *(void**)($esp + 8) → "argument1"

x/s *(void**)($esp + 12) → "argument2"

x/s *(void**)($esp + 16) → "argument 3"

4. Самостоятельная работа
4.1 Программа с подпрограммой (lab09-4.asm)
Преобразование программы из лабораторной работы № с использованием подпрограммы:
https://captures/capture22.png

Тестирование программы (ввод N=5):
https://captures/capture23.png

4.2 Отладка и исправление программы (lab09-5.asm)
Оригинальная программа с ошибкой (вычисление (3+2)*4+5):

mov ebx,3
mov eax,2
add ebx,eax    ; ebx = 5
mov ecx,4
mul ecx        ; ОШИБКА: eax=2, поэтому 2*4=8
add ebx,5      ; ebx = 10

Отладка в GDB для обнаружения ошибки:
https://captures/capture24.png

Исправленная программа:

mov ebx,3
mov eax,2
add ebx,eax    ; ebx = 5
mov ecx,4
mov eax,ebx    ; ИСПРАВЛЕНИЕ: eax = ebx = 5
mul ecx        ; eax = 5*4 = 20
add eax,5      ; eax = 25

https://captures/capture25.png

Тестирование исправленной программы:
https://captures/capture26.png

Результат: 25 (правильно: (3+2)*4+5 = 5*4+5 = 20+5 = 25)

5. Выводы
В ходе лабораторной работы были успешно выполнены все поставленные задачи:

Освоены подпрограммы в NASM: созданы и использованы подпрограммы _calcul и _subcalcul для вычисления сложных выражений.

Приобретены навыки отладки с GDB:

Установка точек останова (по имени метки и по адресу)

Пошаговое выполнение (stepi, nexti)

Просмотр и изменение регистров и памяти

Дизассемблирование в разных синтаксисах (AT&T/Intel)

Исследованы механизмы передачи данных:

Работа со стеком при вызове подпрограмм

Анализ аргументов командной строки в стеке

Найден и исправлен логическая ошибка в программе вычисления арифметического выражения с использованием отладчика GDB.

Преобразована программа из предыдущей лабораторной работы для использования подпрограмм.

Цель работы достигнута полностью: приобретены практические навыки написания программ с подпрограммами и использования отладчика GDB для поиска и исправления ошибок.

6. Ответы на вопросы для самопроверки
Какие языковые средства используются в ассемблере для оформления и активизации подпрограмм?
Инструкции call (вызов) и ret (возврат), использование стека для сохранения адреса возврата.

Объясните механизм вызова подпрограмм.
call сохраняет адрес следующей инструкции в стеке и передает управление на адрес подпрограммы. ret извлекает адрес возврата из стека.

Как используется стек для обеспечения взаимодействия между вызывающей и вызываемой процедурами?
Стек используется для сохранения адреса возврата, передачи параметров и сохранения значений регистров.

Каково назначение операнда в команде ret?
В NASM ret без операнда просто возвращает управление. С операндом ret N дополнительно очищает N байт из стека.

Для чего нужен отладчик?
Для анализа выполнения программы, поиска ошибок, просмотра состояния регистров и памяти.

Объясните назначение отладочной информации и как нужно компилировать программу, чтобы в ней присутствовала отладочная информация.
Отладочная информация связывает машинный код с исходным текстом. Компиляция с ключом -g.

Расшифруйте и объясните следующие термины: breakpoint, watchpoint, checkpoint, catchpoint и call stack.

Breakpoint: точка останова (остановка на конкретной строке/адресе)

Watchpoint: точка наблюдения (остановка при изменении переменной)

Call stack: стек вызовов (история вызовов подпрограмм)

Назовите основные команды отладчика gdb и как они могут быть использованы для отладки программ.

break: установка точки останова

run: запуск программы

stepi/nexti: пошаговое выполнение

info registers: просмотр регистров

x: просмотр памяти

print: вывод значений


